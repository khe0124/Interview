## 컴포넌트와 모듈의 차이?
이 두 용어는 다른 많은 용어들과 마찬가지로 소프트웨어가 아닌 다른 필드에서도 많이 사용이 되고 있는데다 모두 소프트웨어 공학에서 동작과 관련되어 나오기 때문에 구분하기가 힘들다.
먼저 각 용어의 배경에 대해 알아보자.
1960년대 그리고 70년대에 들어서면서 소프트웨어가 더 이상 한 사람이 감당하기 힘들 만큼 복잡해지고 커져 새로운 해결책이 필요했다.
이 문제에 대한 지배적인 해결책은 
캡슐화 Encapsulation
정보 숨김 Information hiding
추상 데이터 타입 Abstract data types
이 세가지 였는데 이때까지만 해도 컴퓨터 프로그램이 올바른 답을 계산하는 부분에 초첨을 두고 있다가
이제 어떻게 코드를 구조화하는지가 시스템의 다른 중요한 속성들을 결정을 내린다는 생각이 나오기 시작하면서 Module이라는 개념도 같이 나오게 되었다. 그러면서 70~80년대에 Module Interconnection Language가 도래한다.
대표적으로 Modula modules, Smalltalk 클래스, Ada 패키지, 그리고 오늘날의 지배적인 설계 패러다임인 Object Oriented Programming도 모듈 컨셉을 가지고 있다.

한편 Component는 컴포넌트기반 소프트웨어 공학과 소프트웨어 아키텍처 필드에서 Componenet-and-Connector로 각광을 받고 있다.
두 용어 모두 목적은 전체 시스템을 구성하는 부분 부분으로 분해시키는 것인데 Module의 경우 가장 첫 번째 그리고 가장 맨 앞에 위치하는 구현의 단위이다. Parnas (1972) 의 모듈 설계에서 기본적인 작업은 '정보 숨김'을 기준으로 사용하는 것이었다. 시간이 지날 수록 변하는 정보 예를 들면 데이터 구조나 알고리즘은 모듈에 할당되고 모듈은 접근을 가능하게 하는 인터페이스를 가진다. 모듈은 오랜시간 소스코드와 관련있었지만 정보 모델, XML 파일, config 파일, BNF 파일 등 다른 구현 산출물도 모듈로 적합하다.
Component는 런타임 개체를 참조한다. Szyperski (1998)는 컴포넌트를 "독립적으로 배포될 수 있고 써드 파티로부터의 결합 대상"이라고 말한다. 실제로 운용 모델에서는 컴포넌트가 오직 실행 가능한 바이너리형식으로 전달된다고 한다.
즉, 모듈은 구현 단위와 산출물을 제안는 반면 매체의 전달과 런타임에 일어나는 일은 강조하지 않는다. 컴포넌트는 소프트웨어 활동 단위로 구현 구조에는 가시성이 없다.
좀 더 이해를 명확하게 하려면 Client-Server 시스템의 예를 보면 된다.
하나의 서버가 10개의 클라이언트에게 정보를 제공할 때, 모듈은 2개를 가지지만 컴포넌트는 11개가 된다. 
모듈은 하나의 컴포넌트 또는 여러 개의 컴포넌트로 표현될 수 있고, 컴포넌트도 마찬가지로 하나의 모듈 또는 여러 개의 모듈로 표현될 수 있다. 때로는 모듈과 컴포넌트가 one-to-one 매핑이 될 수 있지만 그럼에도 불구하고 그 둘은 다른 요소라는 것은 분명하다.

출처: https://imcreator.tistory.com/7 [인문과 공학의 사이 어느 중간쯤]

## 자바의 구동원리 (컴파일 순서 같은 ?)
1. 소스코드를 작성한다. (.java 확장자의 소스 파일)
2. 컴파일러(javac.exe)가 바이트코드로 변환한다. (.class 확장자의 클래스 파일)
3. 런처(java.exe)로 자바 가상 머신을 구동시킨다.
4. 자바 가상 머신이 바이트코드를 해석하여 자바 프로그램이 실행된다.
위 순서에서 바이트코드(bytecode)는 자바 가상 머신이 이해할 수 있는 언어로 변환된 코드다. 자바 가상 머신만 설치되어 있다면 바이트코드는 어떤 운영체제에서라도 실행될 수 있다.

## JVM의 특징
즉, 자바 프로그램의 클래스 파일들은 운영체제에서 직접 동작하는 것이 아니라 "JVM" 위에서 동작한다. 그래서 윈도우에서 개발한다면 윈도우용 가상 머신을 설치하고 맥에서 개발한다면 맥용 가상 머신을 설치하는 등의 운영체제용 가상 머신만 설치가 되어 있다면 자바 프로그램은 한 번 만들기만 하면 윈도우든 리눅스든 맥이든, 어느 운영체제든 실행할 수 있다. (=플랫폼 독립성, 이식성이 높다) 
다만, 플랫폼 독립성에 따라 각 운영체제에 맞는 가상 머신을 설치해야 하므로 운영체제에 종속적이다. 그리고 자바 프로그램은 일반 프로그램보다 한 단계를 더 거쳐야 하므로 상대적으로 실행 속도가 느리다는 단점이 있다.

### 왜 자바 가상 머신(JVM) 구조를 알아야 하는가?
출처 : ttp://stophyun.tistory.com/37
백문이 불여일견. 위 사진을 보면 정보시스템의 성능저하 요인 중 무시 못 할 수치로 JVM 및 메모리 문제가 보인다. 시스템의 성능을 높이기 위해 자바 가상 머신의 구성과 메모리를 아는 것은 자바 개발자로서 필수적인 일이다. 특히나 메모리는 사용할 수 있는 공간이 한정되어 있기에 어떻게 관리하느냐에 따라 프로그램의 성능이 좌우된다. 따라서 메모리를 효율적으로 사용하기 위해서는 메모리의 구성과 각 특징에 대해서 이해할 필요가 있다.

### 자바 가상 머신의 구성

출처 : http://gurubee.tistory.com/14
#### 클래스 로더(Class Loader)
런타임 시 클래스 파일들을 JVM 내부로 로딩하고, 클래스 파일을 분석한 뒤에 각각 런타임 데이터 영역에 배치한다. 자바는 동적으로 클래스를 읽어오므로(동적 로딩) 런타임 시점에서야 모든 코드가 JVM과 연결된다. 

#### 런타임 데이터 영역(Runtime Data Areas)
클래스 로더에서 분석된 클래스 파일의 데이터를 저장하고 실행 도중에 필요한 데이터를 저장한다. 메모리를 효율적으로 관리하기 위해 크게 5개의 영역(스태틱, 힙, 스택, PC 레지스터, 네이티브 메서드 스택)으로 구분하며, 간단히 메모리 영역이라고 부른다.

#### 실행 엔진(Execution Engine)
런타임 데이터 영역에 배치된 바이트코드를 해석하며 실행한다. 이 때 인터프리터 방식과 JIT 컴파일 방식을 혼합하여 해석한다.

#### 인터프리터(Interpreter) 방식
바이트코드를 한 줄씩 읽고 해석한다.

#### JIT 컴파일(Just-In-Time compile) 방식
바이트코드를 런타임 시점에 바로 기계어로 변환한다.
최초의 가상 머신은 인터프리터 방식만 써서 실행 속도가 느렸지만, JIT 컴파일 방식을 추가하여 이를 보완하고자 했다. 그런데 JIT 컴파일은 바이트코드를 기계어로 바꾸기 때문에 실행 속도가 빠르지만 변환하는 데 비용이 발생하게 된다. 그래서 인터프리터 방식을 사용하다가 일정한 기준이 넘어가면 JIT 컴파일 방식으로 실행한다.

### 가비지 컬렉터(Garbage Collector)
때에 따라 가비지 컬렉터가 메모리 관리 기능을 자동으로 수행한다. 더 이상 사용되지 않는 객체를 해제시켜 메모리를 자동으로 반납한다.

### 자바의 메모리 영역
런타임 데이터 영역은 실제 클래스 파일들이 배치되는 곳으로, 자바 프로그램을 실행하기 위해서 가상 머신(JVM)이 운영체제로부터 메모리에 데이터 및 명령어를 저장할 공간을 할당받는 곳이다. 5개의 영역으로 분류되지만 주로 메서드, 힙, 스택 영역이 언급된다.

####  메서드(클래스,스태틱)
- 가장 먼저 데이터가 저장되는 공간
- 클래스 로더에 의해 로딩된 클래스, 메서드, 클래스변수(static), 전역변수가 저장됨
- 클래스변수나 전역변수를 무분별하게 많이 사용하면 메모리가 부족할 수 있음
- 프로그램의 시작부터 종료까지 메모리에 남는다.
- 명시적인 Null 선언시 GC 청소대상
- 모든 스레드 공유

####  힙
- 런타임 시 결정되는 참조형 데이터타입이 저장되는 공간
- new 연산자를 통해 생성된 객체가 저장되는 공간
- 객체가 더 이상 안쓰이거나, 명시적인 Null 선언시 GC 청소대상
- 모든 스레드 공유

####  스택
- 컴파일 시 결정되는 기본형 데이터타입이 저장되는 공간
- 지역변수, 매개변수, 리턴값, 참조변수 등이 저장됨
- 메서드 호출될 때, 메모리에 FILO로 하나씩 생성
- 메서드 끝날 때, 메모리에 LIFO로 하나씩 제거
- 메서드 호출시마다 각각의 스택프레임(그 메서드만의 방)이 생성
- { } 또는 메서드가 끝날 때까지 (끝날 땐 프레임별로 삭제)
- 각 스레드별로 생성

#### PC레지스터
- JVM이 수행할 명령어의 주소를 저장하는 공간
- 스레드가 시작될 때마다 생성
- 각 스레드별로 생성

#### 네이티브 메서드 스택
- 바이트코드가 아닌, 기계어로 작성된 코드를 실행하는 공간
- 다른 언어(C/C++)로 작성된 코드를 수행하기 위함
- Java Native Interface를 통해 바이트코드로 변환됨
- Java Native Interface 호출 및 종료시 생성
- 각 스레드별로 생성

출처: https://gbsb.tistory.com/2

## 객체 지향과 절차지향의 차이점

### 절차지향 프로그래밍 -
물이 위에서 아래로 흐르듯 순차적인 처리가 중요합니다. 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다. 대표적인 절차지향 언어로는 C언어가 있습니다. 이는 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빠른 처리 시간을 가지게 되는 점에서 유리합니다. 그러나 기술이 발전되고 소프트웨어, 하드웨어가 발전함에 따라 상황은 많이 달라졌습니다. 전에는 하드웨어와 소프트웨어의 개발 속도의 차가 크지 않았지만 소프트웨어 언어의 발달과 컴파일러의 발달로 하드웨어가 소프트웨어의 발달을 따라오지 못하는 상황이 발생했습니다. 이는 객체지향 언어가 등장하게 되는 계기로 작용했습니다. 객체지향 프로그래밍은 개발하려는 것을 기능별로 묶어 모듈화하며 하드웨어가 같은 기능을 중복으로 연산하지 않도록 하고 모듈을 재활용하여 하드웨어의 처리량을 획기적으로 줄일 수 있게 되었습니다.

### 객체지향 프로그래밍
실제 세계를 모델링해 소프트웨어를 개발하는 방법입니다. 객체지향 프로그래밍에서는 데이터와 절차를 하나의 덩어리로 묶어서 생각합니다. 마치 컴퓨터 부품을 하나씩 구매해 컴퓨터를 조립하는 것과 같은 방식입니다.
객체지향의 3가지 특성에 대해 알아보겠습니다.

#### 1. 캡슐화
캡슐화는 관련된 데이터와 알고리즘(코드)이 하나의 묶음으로 정리된 것으로, 개발자가 만들었으며 관련된 코드와 데이터가 묶여 있고 오류가 없어 사용이 편합니다. 데이터를 감추고 외부 세계와의 상효 작용은 메소드를 통해 이루어지며 라이브러리를 만들어 업그레이드하면 쉽게 바꿀 수 있습니다.
여기서 메소드란 메시지에 따라 실행시킬 프로시저로서 객체지향 언어에서 사용되는 것입니다. 객체 지향 언어에서는 메시지를 보내 메소드를 수행시킴으로써 통신을 수행합니다.

#### 2. 상속
상속은 이미 작성된 클래스를 이어 받아 새로운 클래스를 생성하는 기법으로 위에서 말한 기존 코드를 재활용하여 사용하는 것을 의미합니다. 객체지향의 큰 장점 중 하나입니다.

#### 3. 다형성
다형성은 하나의 이름으로 많은 상황에 대처하는 방법입니다. 개념적으로 동일한 작업을 하는 함수들에 같은 이름을 부여할 수 있으며 코드가 더 간단해지는 효과가 있습니다.

위의 특성들로 생기는 객체지향의 장점은 다음과 같습니다.

- 신뢰성 있는 소프트웨어를 쉽게 작성할 수 있다.
- 코드를 재사용하기 쉽다.
- 업그레이드가 쉽다.
- 디버깅이 쉽다.

이론적으로 본다면 객체지향 언어는 절차지향 언어에 비해서 장점이 많은 편입니다. 하지만 프로그래밍에서 항상 객체지향 언어를 사용하는 것은 아닙니다. 객체지향 언어는 어떤 하나의 기능만 필요하더라도 전체를 가져와야하기 때문에 절차지향 프로그래밍보다 프로그램의 사이즈가 커질 수도 있습니다. 또한 데이터에 접근하는 것도 절차지향보다 상대적으로 느려질 가능성이 많습니다. 메소드를 통해 접근이 가능하기 때문에 절차지향처럼 1개를 딱 찝어 접근할 수 없으며 참조하에 접근이 가능하므로 속도적인 측면에서 불이익이 있습니다.

그럼 절차지향, 객체지향을 어느 때 쓰느냐에 대해 궁금하실 수 있을텐데 이것은 개발자의 몫이라고 볼 수 있습니다. 코드의 사이즈를 최소화하고 가장 빠르게 동작하는 것이 최우선의 목적이라면 객체지향보다는 절차지향을 사용하는게 좋습니다. 대부분 C로 구성하고 C++를 쓴다 하더라도 절차지향의 방식으로 사용합니다. 반면 PC 플랫폼의 경우에는 객체지향이 대세입니다. PC는 모바일 디바이스에 비해 무한한 자원을 확보하기 때문에 위에서 말한 오버로드가 아무 것도 아닌 것이 됩니다. 예를 들면 물이 든 컵에 물 한 수저를 넣으면 높이에 차가 있지만 큰 수영장에 물을 한 수저 넣는다고해서 높이의 차가 거의 생기지 않는 것과 비슷합니다. 그정도의 오버로드는 무시가 될 수 있고 대부분 개발 툴들이 이미 객체지향의 형태로 제공되고 있습니다.

출처: https://loadofprogrammer.tistory.com/144 [큰 꿈을 그리는 프로그래머의 공간.]

## 객체지향 언어의 특징(상속 추상 등등 …)
### 1. 추상화
추상화라고 하는 것은 객체들의 공통적인 특징(속성 과 기능)을 뽑아내는 것이다.
즉, 우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 도출해 내는 것을 의미한다.
추상화는 절차지향 프로그래밍에서도 있어왔다. 대표적인 것이 구조체와 같은 사용자 데이터형이다.
이것은 데이터를 추상화해서 하나의 새로운 데이터 유형을 만드는 것이다. 예를들어 struct와 같은 구조체가 있다.
하나의 새로운 데이터형을 정의하는 데 그 안에는 여러개의 부속데이터를 둘 수 있다. 이 때 그 데이터를 추상화를 통해 정의한 것이다.

### 2. 캡슐화
객체지향에서 캡슐화는 데이터 구조와 데이터를 다루는 방법을 결합시켜 묶는 것을 말한다.
특정 객체가 독립적으로 역할을 제대로 수행하기 위해 필요한 데이터와 기능을 하나로 묶어 관리한다.
객체가 맡은 역할을 수행하기 위한 하나의 목적을 위해 데이터와 기능들을 묶는 것이다.
또한, 이러한 특징은 다른 의미로 사용되기도 한다. 데이터를 은닉하고 그 데이터를 접근하는 기능을 노출시키지 않는다는 의미로 사용할 때 캡슐화라는 용어를 사용한다. 즉, 데이터를 기능이라는 캡슐로 보호한다는 것이다.

### 3. 상속성
상속이 없으면 객체지향은 절차지향과 별 다른 바가 없다.
상속이란 특징을 가지면서 객체지향 언어가 절차지향 언어의 비해 문법의 규모가 2배이상 늘어났다. 상속이란 상위개념의 특징을 하위 개념이 물려받는 것을 말한다. 하나의 클래스가 가지고 있는 특징(데이터와 함수)들을 그대로 다른 클래스가 물려주고자 할 때 상속성의 특징을 사용한다.

### 4. 다형성
가장 까다롭고 이해하기 어려운 특징으로 잘 이해하고 활용한다면 객체지향 언어를 제대로 쓰는 것으로 봐도 무방할 정도이다.
다형성의 의미는 약간 다른 방법으로 일을 하는 함수를 동일한 이름으로 호출해 주는 것을 말한다.

출처: https://sesok808.tistory.com/31 [살아가는 그 이유]

## 상속과 구현의 차이점 과 특징 및 장단점
### 인터페이스란?
구현부가 따로 없는 클래스
이는 생길 때 애초부터,  무언가를 구현하기 위해 만들어 지지 않았다는 이야기다.
자신만의 색을 나타내기 위해 만들어 졌다.  정체성을 가지면 통일된 목소리를 낼 수 있다. 그것이 목적이다.
### implements(구현상속)은?
사용하는 경우는, 추상클래스, 인터페이스를 구현받은 경우다.
인터페이스를 구현받아, 인터페이스에 쓰여진 대로 자신의 형태를 구현한다.
추상클래스와 인터페이스의 차이는 순수하게 물려받은 내용대로만 구현하고 말껀가? 아니면 그 외의 내용을 따로 구현 할껀가의 차이이다.
### extends(순수상속)은?
다른 클래스의 구현부를 재 사용하겠다는 뜻이며, 이 경우 특별한 구현없이 상속받은 다른 클래스의 내용을 자신의 코드처럼 사용할 수 있다.
물론 부모가 준 코드가 맘에 안 들면, 상속 받은 코드를 버리고 자신이 다시 작성하는 것이다.  오버라이딩이라고 부른다.

## 오버라이딩 오버로딩의 차이점과 특징
### 오버로딩이란
두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우를 말한다.

### 오버라이딩이란
상위 클래스의 메서드와 이름과 용례(signature)가 같은 함수를 하위 클래스에 재정의하는 것을 말한다.
즉, 상속 관계에 있는 클래스 간에 같은 이름의 메서드를 정의하는 것을 말한다.

출처: https://gmlwjd9405.github.io/2018/08/09/java-overloading-vs-overriding.html

## 기본형 변수와 참조형 변수가 뭐가있나

### 기본형(primitive type) 변수
boolean, char, byte, short, int, long, float, double
실제 연산에 사용되는 것은 모두 기본형 변수입니다.

### 참조형(reference type) 변수
기본형 8가지를 제외한 나머지 타입
참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조형 변수의 타입이 됩니다. 따라서 새로운 클래스를 작성하는 것은 새로운 참조형 변수를 추가한다고 봐도 무방합니다.

`Date today = new Date();`
Date 클래스 타입의 참조형 변수 today를 선언한 것입니다.
참조형 변수는 null 또는 주소를 값으로 갖습니다.
연산자 new의 결과는 생성된 객체의 주소이다. 이 주소가 대입연산자 =에 의해서 참조형 변수 today에 저장되는 것입니다.

### 참조(reference)
참조와 참조형 변수는 다른 개념입니다.
참조는 참조형 변수가 아닌 참조값(reference value, 해쉬코드)입니다.
예를 들자면 A x = new A();의 경우 new가 반환한 참조(reference)는 new A();의 반환값이고, 참조형 변수(reference variable)는 x입니다.

출처: https://sambalim.tistory.com/73 [삼바의 성장 블로그]

## 스택오버 플로우가 왜일어나나
Java 응용 프로그램에서 함수 호출을 호출하면 호출 스택 에 스택 프레임 이 할당됩니다. stack frame 은 호출 된 메소드의 매개 변수, 로컬 매개 변수 및 메소드의 리턴 주소를 포함합니다. 반환 주소는 호출 된 메서드가 반환 된 후 프로그램 실행이 계속되는 실행 지점을 나타냅니다. 새로운 스택 프레임을위한 공간이 없으면 JVM (Java Virtual Machine)에 의해 StackOverflowError 가 발생합니다.

Java 응용 프로그램의 스택을 완전히 소모 할 수있는 가장 일반적인 경우는 재귀입니다. 재귀에서는 메서드가 실행되는 동안 자체를 호출합니다. StackOverflowError 를 피하기 위해서는 가장 강력한 범용 프로그래밍 기법 중 하나를 Recursion 으로 사용해야하지만주의해서 사용해야합니다.

## 메모리 누수가 무엇인가
메모리 누수란 Garbage Collection되어야 할 메모리가 정리되지 못하고 계속 Java의 메모리 공간에 남아있는 현상을 말한다. 이 Memory Leak이 계속 되면 결국 OOM( Out Of Memory - 메모리 부족)현상이 발생해서 어플리케이션이 더이상 동작하지 못하고 JVM이 종료되는 최악의 상황이 된다. 그러므로 상용, 특히 24시간 서비스하는 웹서버등의 경우에는 항상 이 메모리 누수 현상이 발생하지 않는지 관심을 둘 필요가 있다.
 메모리 릭의 양이 아주 작고 메모리는 많은 경우에는 주기적으로 JVM을 재시작 하면서 크게 신경안써도 될 경우도 있지만,  메모리릭이 빠르게 증가하는 경우에는 반드시 해결해줘야 한다.
 
[출처] 자바 - OOM 메모리 릭 찾기 이론편 ( Java - finding memory leak of OOM #1 )|작성자 IDEO

## 메모리 누수를 막기위해 어떻게 해야하나
### 정확한 메모리 사용량 측정법
자바 프로그램의 실제 메모리 사용량은 시스템의 작업 관리자에서 나오는 메모리 사용량으로는
측정의 정확도가 매우 떨어진다.
따라서, 개발자 수준에서 메모리 사용량을 측정하고 개선하기 위해서는,
자바 어플리케이션의 메모리 사용량은 디버그 출력으로 totalMemory() - freeMemory()를
출력하거나, OptimizeIt과 같은 개발도구로 측정하는 것이 좋다.
 
### 메모리 누수(leak)의 심각성
자바에서는 GC에 의해 메모리가 자동 관리되어 memory leak가 없다고 하지만,
사실은 memory leak가 발생할 수 있다.
그 이유는 실제로 사용되지 않는 객체의 reference를 프로그램에서 잡고 있으면
그 객체는 GC에 의해 처리되지 않고 프로그램내에서도 접근하여 사용될 수 없는
사실상 쓰레기로서 메모리(보다 정확하게는 주소 공간)를 점유하게 된다.
그러한 메모리 누수 현상이 있으면 창을 열고 닫을 때마다 그리고 문서를 열고 닫을 때마다 
지속적으로 메모리가 증가되어 성능 저하뿐만 아니라 결국에는 메모리 오류 발생으로
프로그램이 종료되는 심각한 현상이 발생한다.
 
### 자바 GC 알고리즘 
이와 같은 자바의 메모리 누수 현상에 대한 정확한 진단과 처방은 때로는 GC 알고리즘에 대한 보다 정확한 이해를 필요로 한다.
자바의 GC 알고리즘은 reference counting을 사용하지 않아서 객체간에 cyclic reference가 생겨도 GC되지 않는 문제가 없는 완벽한 방법이지만 일정 시간의 GC 시간을 필요로 한다는 단점을 가지고 있다.
즉, 자바 heap의 모든 객체는 현재 사용중인 객체와 사용되고 있지 않는 객체, 2가지로 나뉘어지며,
사용중인 객체중에서도 사실상 사용되지 않는 객체가 있을 수 있으며 이는 메모리 누수에 해당한다는 것이다.

현재 사용중인 객체란 다음과 같은 루트 참조 (객체가 아님)들로부터 직간접적으로 참조가 되는 (reachable한) 모든 객체를 의미하며, 나머지 객체는 모두 쓰레기 객체이고, 요즘 JVM은 이러한 쓰레기 객체를 완벽하게 수거하므로 (옛날 버전의 JVM은 그렇지 않았음) 이 단계에서의 메모리 누수는 없다.

이와 같은 루트 참조는 다음과 같이 크게 3가지가 존재한다.
1. static 변수에 의한 객체 참조
2. 모든 현재 자바 스레드 스택내의 지역 변수, 매개 변수에 의한 객체 참조
3. JNI 프로그램에 의해 동적으로 만들어지고 제거되는 JNI global 객체 참조
 
이를 직관적으로 이해하는 방법은 다음과 같다.
GC 알고리즘에서 현재 사용중인 객체의 의미는 현재 생성된 객체들중에서 현재 이후에 참조되어 사용될 가능성이 있는 모든 객체를 의미한다.
객체는 직접 참조되지 않고 항상 변수를 통하여 참조가 가능하다.
static 변수는 프로그램 어디서든 사용할 수 있으므로 static 변수에 의해 참조되는 객체와 그 객체로부터 직간접적으로 참조되는 모든 객체는 언제든 사용될 가능성이 있는 객체라서 사용중인 객체이다.
 
자바에서 현재 실행중인 (각 스레드별로) 모든 메소드내에 선언된 지역 변수와 매개변수에 의해 참조되는 객체와  그 객체로부터 직간접적으로 참조되는 모든 객체는 참조되어 사용될 가능성이 있으며, 이 뿐만 아니라 caller 메소드로 return된 후에는 caller 메소드에서 참조하고 있는 지역변수, 매개변수에 의해 참조되는 객체와  그 객체로부터 직간접적으로 참조되는 모든 객체 또한, 참조되어 사용될 가능성이 있다.

따라서, 각 자바 스레드의 스택 프레임내에 있는 모든 지역변수와 매개 변수에 의해 참조되는 객체와 그 객체로부터 직간접적으로 참조되는 모든 객체들이 참조되어 사용될 가능성이 있다는 것이다.
또한, JNI 네이티브 C 함수내에서도 JNI 함수를 사용하여 자바 객체를 생성할 수 있다.
이때 생성된 자바 객체에 대한 참조를 int 값등으로 변환시켜 C 함수내의 지역 변수, 매개 변수, 전역 변수로 참조하더라도 이는 자바 가상 머쉰의 영역을 벗어나는 것으로서, 즉 자바 스레드 스택이 아닌 네이티브 스택이어서 자바 가상 머쉰의 스레기 수거 기능이 동작하지 못한다. 따라서, 자바의 static 변수나 지역 변수, 매개 변수에 의해 참조되지 않으면서 쓰레기 수거되지 않고 C 변수를 통하여 지속적으로 자바 객체를 접근할 수 있도록 JNI C 함수를 호출하여  JNI global reference로 JVM내에 등록시킬 수 있으며, 물론 등록 해제도 가능하다.

따라서, 자바의 사용되는 메모리란 사용될 가능성이 있다는 것일뿐이므로 논리적으로도 정확하게 사용되고 있는 객체가 아닌 사실상의 쓰레기 객체가 있을 수 있으며 이러한 객체들이 자바나 닷넷 프로그램의 메모리 누수 현상을 초래하는 것이다.
이와 같이 사살상의 쓰레기인지 아닌지는 기계적인 검출이 사실상 곤란하여 툴의 도움을 받을 수 있을지라도 프로그래머가 로직을 이해하여 파악해야 한다.
그렇지 않은 객체들은 어떠한 방법으로도 참조할 수 있는 수단이 없어서 확실하게 쓰레기 객체라는 것을 의미하며, 최근 버전의 자바 가상 머쉰은 이런 확실한 쓰레기 객체는 확실하게 수거해서 재사용되게 해준다.
 
### 메모리 누수 검출을 위한 개발 도구 사용법 
OptimizeIt등의 도구로 보면, 전체 루트 참조 목록을 볼 수 있고 이로부터 참조되는 객체들을 모두 따라갈 수 있으며, 루트 참조들은 위에서 지적한 바와 같이 3가지 중에 1가지로 구분되어 확인할 수 있다.
또한, 특정 객체 참조를 참조하는 객체들을 따라갈 수도 있다.
메모리 누수 검출을 위해서는 메모리 누수 원인이 되는 요주의(?) 대상 객체 (창 객체나 Document 객체등)를 참조하는 객체들을 따라가서 일단 루트까지 따라가야 한다. 루트가 아닌 일반 객체에서 그래프가 끝나는 경우가
많은 데 이는 객체 참조 그래프에서 cycle이 생성되어 끝난 것이며 이러한 객체는 루트 참조가 아니므로 메모리 누수와 관련이 없어서 무시하면 된다.
일반적으로 특정 객에 이를 수 이를 수 있는 루트 참조는 몇개 정도로만 압축되므로 이들 루트 참조들을 위주로 조사를 해보면 되는 것이다.

### 메모리 누수 원인, 처방, 개발자들의 오해 
메모리 누수 원인을 파악할 때 개발자들이 흔히 잘못하는 실수는 객체와 클래스(혹은 코드)의 차이를 명확히 구분하는 것이다. 스레기 수집은 객체들간의 참조 관계로부터 파악되는 것이므로 클래스 구조나 패키지 구조와 별로 관계가 없다. 또한, 이와 같은 메모리 누수가 GUI 어플리케이션과 같이 객체들간에 상호 참조가 많은 경우에는 하나의 객체 참조를 null 처리해주지
않은 실수가 전체 창, 혹은 전체 문서의 메모리 누수로 이어지는 경우가 많다.
그 이유는 Frame에서 부터 시작하여 Frame내에 포함되는 모든 UI 컴포넌트들은 parent 변수와 childs 변수를 통하여 상호 참조하게 되어 전체가 한 덩어리가 되어 이중 한개의 UI 컴포넌트에 대한 참조가 남아있어도 전체 Frame과 여기에 포함된 모든 UI 컴포넌트의 객체들이 사용중인 객체가 되는 것이다.
뿐만 아니라 이벤트 리스너 등록등으로 인하여 UI 컨트롤에서 UI 컨트롤이 아닌 객체로의 참조가 남아서 메모리 누수가 더 확대될 수 있다.
비슷한 현상으로 Document, View 구조에서 Document 구조 또한 부모-자식 Element들간에 상호 참조되어 전체가 하나의 군집을 이루고 View 구조의 각 뷰 객체들이 Document를 참조하므로 이들중 1개의 객체라도 그 참조가 남아있으면 (루트 참조에 의해 직간접적으로 참조되면) 전체 Document 객체와 이로부터 직간접적으로 참조되는 모든 객체들의 메모리 누수로 확대된다.
일반적으로 static 변수를 사용하는 이유는 프로그램내에서 전역적으로 데이터를 공유할때 사용한다.
static 변수는 이와 같은 메모리 누수의 원인이 되는 경우가 많으므로 굳이 static 변수를 써야만 하는 상황이 아니라면 인스턴스 변수를 사용하도록 프로그래밍시에 유의해야 한다.
즉, GUI 어플리케이션의 경우, 창 객체 참조나 문서 객체 참조를 통하여 이러한 인스턴스 변수를 (직간접적으로) 접근하도록 하는 것이다.
만약, 그 static 변수가 필히 사용될 필요가 있다면 그 static 변수로부터 창 객체나 문서 객체에 참조로 이르는 참조 그래프내의 참조 경로상의 적정 시점에서 null 대입을 통하여 그 static 변수로부터 문서 객체(혹은 창 객체)에 이르는 모든 가능한 참조 경로를 끊어주어야 한다.
가령, static 변수에 의해 참조되는 Vector에 이벤트 처리를 위해서 문서 객체나 창 객체 혹은 이들에 대한 구성 객체를 등록한 경우에는 다음과 같이 2가지 해결방법이 있다.
 
1. 그 이벤트 처리기 목록에 등록되는 객체들이 특정 창 혹은 특정 문서가 열렸을 경우에만 유효한 객체들로 분리시켜 관리할 수 있는 경우에는 이벤트 처리기 목록에 등록되는 객체 참조를 저장하는 static 변수를 창 객체나 문서 객체를 통하여 접근할 수 있는 아마 인스턴스 메소드로 접근하게 될) 인스턴스 변수에 저장하는 것이 가장 이상적이며, 이 경우 창을 닫거나 문서를 닫을때  reference를 끊어주는 처리를 전혀 할 필요가 없어 안전하다.

2. 그 이벤트 처리기 목록에 등록되는 객체들이 특정 창 혹은 특정 문서와 관련없은 전역적인 객체들이거나 적절히 분류될 수 없다면 static 변수를 사용할 수 밖에 없고, 이 경우 static 변수에 의해 참조되는 Vector내의 관련없는 객체들을 창닫거나 문서닫을 때 제거해주는 처리를 해주어야 한다.
이와 같이 메모리 누수는 대부분의 경우 static 변수가 핵심적인 역할을 하므로, 이를 주의깊게 살펴보면 대부분의 메모리 누수 문제를 해결할 수 있을 것이다.
 
자바 스레드 스택의 지역 변수가 매개 변수에 의한 참조도 살펴볼 필요가 있는데, GUI 어플리케이션에서는 이러한 지역 변수나 매개 변수는 대개의 경우 메모리 누수 문제와 관계가 없다.
그 이유는 GUI 어플리케이션이란 main 메소드와 그 메소드로부터 직간접적으로 메소드들이 끊임없이 호출되는 일반 어플리케이션 모델이 아니라, main 메소드는 창을 연후에 종료되고 일반적으로는 스레드 스택이 모두 비어 있으며 이벤트 루프를 실행시키는 스레드만이 waiting하는 경우가 대부분이라서 스레드 스택에 남아있는 게 없다는 것이다.

하지만, GUI 어플리케이션이더라도 백그라운드 스레드를 사용하는 경우에는 문제가 될 수 있다.
이 백그라운드 스레드가 실행은 되지 않더라도 종료되지 않고 waiting하고 있다면 스레드 스택이 존재하고 지역변수, 매개변수가 살아있어서 이로부터 직간접적으로 참조되는 모든 객체는 사용중인 객체가 되기 때문에 메모리 누수 요인이 될 수 있다.
즉, 요약한다면 GUI 어플리케이션에서는 메모리 누수 원인을 조사하는 데 있어서 지역 변수와 매개변수에 대해서는 백그라운드 스레드만 조사해보면 된다는 것이다.
마지막으로, JNI 전역 참조에 의한 메모리 누수는 크게 2가지 요인이 있을 수 있다.
 
1. 네이티브 코드쪽에서 JNI 전역 참조를 해제하지 않는 버그로 인하여 메모리 누수 발생.
   자바의 GUI 관련 패키지는 이제는 많이 안정화되었고 변화도 많지 않으므로 자바의 GUI 관련 패키지내에서는 이러한 버그가 있을 가능성이 거의 없다.
   JVM에 내장되지 않은 혹은 자체 제작한 JNI 함수내에서 JNI 전역 참조를 해제하지 않는 버그로 인하여 메모리 누수 발생할 수 있는데, 네이티브 코드에서 JNI 전역 참조를 만드는 경우 또한 매우 드문 경우이다.
 
2. 네이티브 자원을 반환하는 dispose(), close() 메소드를 제때에 호출해주지 않아서 메모리 누수 발생.
   이러한 메소드는 기본적으로 JNI 전역 참조를 해제하는 것이 아니고 시스템 자원 
   (시스템 그래픽스, 시스템 윈도우즈, 시스템 파일 descriptor등등)을 반납하는 경우가 대부분이다.
   이들이 사용하는 메모리는 자바힙이 아니라 네이티브 힙등 네이티브 메모리 영역으로서 자바 개발 도구등으로 검출되지 않아서 자바 메모리 누수와 직접적인 관련성이 없다.
   단, 이들 네이티브 자원과 관련된 코드가 JNI 전역 참조를 가지고 있어서 이들 자원이 해제되기 전에는 JNI 전역 참조를 해제하지 않아서 해당 자바 객체의 메모리 누수가 발생할 수 있으나,
   이러한 경우는 일반적으로 드물 것이다. 그 이유는 네이티브 자원은 자바 코드보다 더 low-level한 것으로서 이러한 자원을 관리하는 코드에서 자바 객체에 대한 전역 참조를 관리할 필요성이 대부분 없기 때문이다.

메모리 누수 원인을 조사할 때 다음과 같은 순서로 문제 발생 가능성, 누수 원인이 미치는 메모리 누수량, 문제 원인 진단의 용이성이 높으므로 이와 같은 순서로 누수 원인을 철저하게 조사하는 것이 개발 효율적이다.
 
1. static 참조
2. 백그라인드 스레드의 지역, 매개 변수
3. 네이티브 코드내의 JNI 전역 참조
 
### 캐쉬와 관련된 메모리 누수 
캐쉬는 일반적으로 캐쉬 엔트리에 대한 접근을 위해 키와 value로 이루어지고 HashMap등으로 관리되며, 메모리를 추가로 사용하여 속도 성능 효율을 얻는 것이 주목적이다.
이 캐쉬의 각 엔트리는 언제든 제거되어도 상관없으며, 키나 키와 관련된 데이터로부터 원본 value 객체에 접근하여 언제든 원본 value에 접근하여 가져올 수 있다는 특징을 갖는다.
그러나, 보통 간단하게 구현된 캐쉬는 캐쉬가 자꾸 커지기만 할뿐 줄어들지 않아서 메모리 누수가 발생할 수 있다.

일반적으로 변수에 대입한 참조들은 모두 강 참조(strong reference)이다.
강 참조만으로 이루어진 HashMap에서는 메모리 부족 상태를 파악하여 캐쉬 엔트리에 대한 참조를 적절히 제거해주면 메모리 누수가 발생하지 않을 수 있으나 메모리 부족 상태를 파악하기 어렵고 추가 작업을 해야 하므로 이와 같이 처리하지 않는 경우가 대부분이다.
하지만, 약간의 코딩으로 이러한 메모리 누수를 해결할 수 있는 방법이 있다.
이러한 용도로 사용할 수 있는 것이 SoftReference, WeakReference라는 것이 있다. (PhantomReference도 있는 데 잘 사용되지 않는다.)
SoftReference, WeakReference 객체를 사용하여 소프트 참조, 약 참조를 사용하면 이러한 참조 객체에 의해 참조되는 객체는 메모리가 부족해지면 JVM에 의해서 모두 null 참조로 바뀌고 쓰레기 수집된다.

예전에 실험해본 바에 의하면 소프트 참조와 약 참조 모두 할당된 자바 힙 크기가 부족해질 경우에만 비로서 쓰레기 수집되었다.
따라서, 메모리 누수는 없을지라도 사실상의 메모리 누수와 유사한 성능상 나쁜 효과를 초래할 수 있다.

소프트 참조와 약 참조는 최대 자바 힙 크기에 이를때까지 쓰레기 수집 되지 않고 최대 자바 힙 크기에 이를 때까지 메모리를 차지하여 현실적으로는 더 많은 메모리를 (더 정확히는 가상 주소 공간과 가상 메모리)를 사용하여 RAM 메모리 효율성이 떨어져서 성능 저하 효과를 가져올 수 있다.
문서 객체나 창 객체에 종속적인 캐쉬는 문서나 창이 닫힐때 캐쉬 전체를 null 대입함으로써 이와 같은 메모리 누수 문제 혹은 메모리 효율성 저하 문제를 해결할 수 있다.

Toolkit 클래스의 getImage 메소드 같은 경우에는 동일 URL에 있는 이미지를 여러번 참조하는 경우를 대비하여 효율성을 위해서 URL(혹은 파일 경로명)을 키로 하여 이미지 객체를 캐슁하여 사용한다.
이때, URL로부터 언제든 원본 이미지 데이터에 접근하여 이미지 객체를 생성할 수 있으므로 JVM 내에서는 소프트 참조로 구현되어 있으므로 메모리 부족시에는 자동으로 쓰레기 수집되므로 꼭 메모리 누수는 아니나, 상기에 언급한 이유로 메모리 효율성이 저하될 수 있다.
Toolkit 클래스의 getImage 같은 편의상 제공되는 메소드는 최적화에는 방해가 될 수 있으므로 사용하지 않는 것이 좋다.

문서내의 이미지들을 Toolkit 클래스의 getImage를 사용하지 않는다고 해도 JVM 전역적인 캐쉬를 만들어서 사용하면 메모리 누수나 메모리 효율성 저하 문제가 발생한다.
따라서, 주어진 문서내의 이미지만을 저장하는 캐쉬를 사용하고 그 문서가 닫힐 때 해당 문서 이미지 캐쉬에 대한 참조를 반환하면 이미지 캐쉬에 대한 메모리 문제를 해결할 수 있다.
이미지 캐쉬는 메모리를 많이 사용하므로 주의 대상이 된다.
 

### 자바힙 메모리 관리와 시스템 메모리 관리와의 관계 
일반적으로 윈도우즈에서 프로그램의 메모리 사용량은 작업 관리자를 열어서 메모리 사용량과 가상 메모리 사용량을 측정할 수 있는데, C 프로그램보다 자바 프로그램이 휠씬 많은 메모리를 사용하는 것으로 측정되는 경우가 많다.

그러나, 자바에서의 메모리 사용량이 MS 오피스와 같은 네이티브 어플리케이션만큼 메모리를 많이 사용한다고 해도 그 차이만큼 실제 메모리를 꼭 많이 쓰는 것은 아니다.
자바가 시스템으로부터 할당된 메모리중의 일부를 자바 힙이 사용하고 이 힙의 일부는 아직 자바 객체에 할당되지 않아서 실제 메모리로 할당될 가능성이 작고, 프로그램간 공유되는 메모리의 크기는 잘 측정되지 않기 때문이다.
 
MS사의 MSDN이나 Knowledge base를 뒤져봐도 메모리 사용량, 가상 메모리 사용량 및 이와 관련된 메모리 성능을 제대로 평가하는 데 필요한 많은 메카니즘들이 소개되어 있지 않다.
향후 이를 좀더 정확히 이해하고 자바의 GC 알고리즘의 메모리 성능 효과를 이해하게 되면
자바에서의 메모리 사용량이 그렇게 큰 문제는 아니라는 것을 명확하게 설명할 수 있을 것이며,
이를 뒷받침하는 구체적인 실험 결과를 제공할 수 있을 것이다.
만약, 실험에 의해서도 메모리 성능 문제가 심각하다면 정확한 이해를 바탕으로 이를 위한 개선 방안을 찾아볼 수 있다.

[출처] 자바 메모리 누수의 원인과 처방 |작성자 김덕태

## static에 대해 설명해봐라
### static
static이라는 의미는 ‘정적인, 움직이지 않는다.’는 뜻이다. 메모리에서 고정되기 때문에 붙은 이름이지만, 실제 소스에서 static을 사용한다는 의미는 모든 객체가 ‘공유’한다는 의미이다.
cf.) 객체지향이라는 패러다임이란 데이터와 기능(로직, 메소드)을 가진 객체들의 커뮤니케이션으로 어떤 작업을 완료하는 것을 의미한다. 
cf.) 객체마다 데이터를 가져도 불편한 때도 있다

예를 들어 여러분이 어떤 쇼핑몰을 운영한다고 가정해보자. 여러분의 시스템에서 발생하는 매출 현황은 비단 여러분뿐 아니라 여러분의 회사의 모든 직원이 알아야 한다.
이 비유는 객체지향 프로그래밍에서도 마찬가지로 적용할 수 있다.

1. 모든 객체가 동일한 데이터를 참고해야 할 필요가 있다.
2. 모든 객체는 데이터에 영향을 줄 수 있다.

### static 중요 법칙
- static이 붙은 변수들은 객체들이 다 같이 공유하는 데이터를 의미한다.
- static이 붙은 메소드들은 객체들의 데이터와 관계없는 완벽하게 공통적인 로직을 정의할 때 사용한다.
- 따라서 static 메소드에서는 인스턴스 변수나 객체의 메소드를 사용할 수 없다.

출처: https://devbox.tistory.com/entry/Java-static [장인개발자를 꿈꾸는 :: 기록하는 공간]

## 싱글턴이 무엇인가 ? 디자인패턴을 아나 ?
### 싱글톤 패턴
애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴.
생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다. (자바에선 생성자를 private로 선언해서 생성 불가하게 하고 getInstance()로 받아쓰기도 함)
=> 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴이다.
(인스턴스가 필요 할 때 똑같은 인스턴스를 만들어 내는 것이 아니라, 동일(기존) 인스턴스를 사용하게함)

### 싱글톤 패턴을 쓰는 이유
고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있음
또한 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.
DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용.
(쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체등)
안드로이드 앱 같은 경우 각 액티비티나 클래스별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 만들어 어디서나 접근하도록 설계하는 것이 편하기 때문...
+ 인스턴스가 절대적으로 한개만 존재하는 것을 보증하고 싶을 경우 사용.
+ 두 번째 이용시부터는 객체 로딩 시간이 현저하게 줄어 성능이 좋아지는 장점!

출처: https://jeong-pro.tistory.com/86 [기본기를 쌓는 정아마추어 코딩블로그]

## 익명클래스와 익명객체를 아나?
### 무명 클래스(Anonymous class)
- 말그대로 몸체는 있으나 이름만 없는 클래스를 의미하며, 하나의 객체만 사용할 경우에 이용한다. 즉, 한번만 사용가능하다.
```java
클래스명 변수명 = new 클래스명 { 클래스 몸체 };
``` 
- 무명 클래스의 선언은 하나의 실행문이므로 끝에 세미콜론(;)이 무조건 붙는다.
- 클래스명에 올 수 있는 것은 상속받고자 하는 부모 클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 적어주면 된다.
- 무명클래스는 클래스를 정의하면서 동시에 객체를 생성하게 된다.
- 코드의 양을 줄일 수 있다는 장점이 있으나 코드가 난해해진다.

### 익명 구현 객체
- 무명클래스를 통해 인터페이스를 구현하고자 하는 일회성의 구현 객체를 말한다.
- 대부분 UI(user interface) 프로그래밍에서 이벤트를 처리하거나 임시 작업 스레드를 만들기 위해 익명 구현 객체를 많이 이용한다.
- 형식 
```java
인터페이스타입 변수명 = new 인터페이스타입() {

//인터페이스에 선언된 추상메소드의 실체 메소드 선언

}; 
```
- 추가적으로 필드와 메소드도 선언이 가능하지만, 익명 객체 안에서만 사용할 수 있고, 해당 변수로는 접근할 수는 없다.

## 쓰레드는 언제쓰고 쓰레드가 무엇인가
하나의 프로세스 내부에서 독립적으로 실행되는 하나의 작업 단위를 말하며, 세부적으로는 운영체제에 의해 관리되는 하나의 작업 혹은 태스크를 의미합니다. 
스레드와 태스크(혹은 작업)은 바꾸어 사용해도 무관합니다.

1. JVM에 의해 하나의 프로세스가 발생하고 main( ) 안의 실행문 들이 하나의 스레드입니다.
2. main( ) 이외의 또 다른 스레드를 만들려면 Thread 클래스를 상속하거나 Runnable 인터페이스를 구현합니다.
3. 다중 스레드 작업 시에는 각 스레드 끼리 정보를 주고받을 수 있어 처리 과정의 오류를 줄일 수 있습니다.
4. 프로세스끼리는 정보를 주고받을 수 없습니다.

## 멀티쓰레드와 쓰레드의 차이점
멀티스레딩이란?
여러 스레드를 동시에 실행시키는 응용프로그램을 작성하는 기법을 말합니다.

장점
1. 메모리 공유로 인한 시스템 자원 소모가 줄어 듭니다.
2. 동시에 두가지 이상의 활동을 하는 것이 가능해집니다.
단점
1. 서로 자원을 소모하다가 충돌이 일어날 가능성이 존재합니다.
2. 코딩이 난해해져 버그생성확률이 높아집니다.

## 제네릭이란 무엇인가
제네릭은 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다. 
즉, 클래스 내부에서 사용할 데이터 타입을 나중에 인스턴스를 생성할 때 확정하는 것을 제네릭이라 한다.
객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.
ArrayList와 같은 컬렉션 클래스는 다양한 종류의 객체를 담을 수 있긴 하지만 보통 한 종류의 객체를 담는 경우가 더 많다. 그런데도 꺼낼 때 마다 타입체크를 하고 형변환을 하는 것은 아무래도 불편할 수 밖에 없다.

출처: https://devbox.tistory.com/entry/Java-제네릭 [장인개발자를 꿈꾸는 :: 기록하는 공간]

## 람다식이란 무엇인가
람다식이란 "식별자없이 실행가능한 함수"
함수인데 함수를 따로 만들지 않고 코드한줄에 함수를 써서 그것을 호출하는 방식이라고 생각하시면 되겠습니다.

함수적 프로그래밍을 위해 자바 8부터 람다식(Lambda Expressions)을 지원하면서 기존의 코드 패턴이 많이 달라졌습니다. 자바스크립트에서 주로 봤었던 문법들을 이제 자바에서도 종종 보이곤 해요. 람다가 처음에는 생소하게 느껴질 수 있지만 문법이 간결한만큼 익숙해지면 가독성 면에서 장점이 큰 듯 합니다.
(고급 프로그래머들중에서는 람다를 최대한 쓰지말라고 하는 사람도 있습니다.)

### 람다식 사용법
```java
(매개변수, ...) -> { 실행문 ... }
```
(매개변수, ...)는 오른쪽 중괄호 { } 블록을 실행하기 위해 필요한 값을 제공하는 역할을 합니다.
매개 변수의 이름은 개발자가 자유롭게 지정할 수 있으며 인자타입도 명시하지 않아도 됩니다.
-> 기호는 매개 변수를 이용해서 중괄호 { } 바디를 실행한다는 뜻으로 해석하면 됩니다.

출처: https://coding-factory.tistory.com/265

## 힙과 스택의 차이점을 알고있는가
### 스택
- 매우 빠른 액세스
- 변수를 명시 적으로 할당 해제 할 필요가 없습니다.
- 공간은 CPU에 의해 효율적으로 관리되고 메모리는 단편화되지 않습니다.
- 지역 변수 만
- 스택 크기 제한 (OS에 따라 다름)
- 변수의 크기를 조정할 수 없습니다.
### 힙
- 변수는 전역 적으로 액세스 할 수 있습니다.
- 메모리 크기 제한 없음
- (상대적으로) 느린 액세스
- 효율적인 공간 사용을 보장하지 못하면 메모리 블록이 할당 된 후 시간이 지남에 따라 메모리가 조각화되어 해제 될 수 있습니다.
- 메모리를 관리해야합니다 (변수를 할당하고 해제하는 책임이 있습니다)
- 변수는 C언어 realloc() or 자바 new

## TCP와 UDP의 차이점
### TCP 서버의 특징
- 서버소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다형 서비스로 가상 회선 방식을 제공한다.
- 서버와 클라이언트는 1대1로 연결된다.
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다.
- Streaming 서비스에 불리하다.(손실된 경우 재전송 요청을 하므로)

### UDP의 특징
- 비연결형 서비스로 데이터그램 방식을 제공한다
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다
- TCP보다 속도가 빠르다

## http프로토콜에대해서아냐 ?
HTTP(HyperText Transfer Protocol, 문화어: 초본문전송규약, 하이퍼본문전송규약)는 WWW 상에서 정보를 주고받을 수 있는 프로토콜이다. 
주로 HTML 문서를 주고받는 데에 쓰인다. TCP와 UDP를 사용하며, 80번 포트를 사용한다. 1996년 버전 1.0, 그리고 1999년 1.1이 각각 발표되었다.
HTTP는 클라이언트와 서버 사이에 이루어지는 요청/응답(request/response) 프로토콜이다. 예를 들면, 클라이언트인 웹 브라우저가 HTTP를 통하여 서버로부터 웹페이지나 그림 정보를 요청하면, 서버는 이 요청에 응답하여 필요한 정보를 해당 사용자에게 전달하게 된다. 이 정보가 모니터와 같은 출력 장치를 통해 사용자에게 나타나는 것이다.
HTTP를 통해 전달되는 자료는 http:로 시작하는 URL(인터넷 주소)로 조회할 수 있다.

### 메시지 포맷
클라이언트와 서버 사이의 소통은 평문(ASCII) 메시지로 이루어진다. 클라이언트는 서버로 요청메시지를 전달하며 서버는 응답메시지를 보낸다.

### 요청 메시지
클라이언트가 서버에게 보내는 요청 메시지는 다음과 같다.

#### 요청 내용
보기) GET /images/logo.gif HTTP/1.1
#### 헤더
보기) Accept-Language: en
#### 빈 줄 (empty line)
기타 메시지를 포함하여 표시된다.
요청 내용과 헤더 필드는 <CR><LF>로 끝나야 한다. 즉, 캐리지 리턴(Carriage Return) 다음에 라인 피드(Line Feed)가 와야 한다. 빈 줄(empty line)은 <CR><LF>로 구성되며 그 외 다른 화이트스페이스(whitespace)가 있어서는 안된다.
 
#### 응답 메시지
응답 메시지는 다음으로 구성된다.
상태표시 행(status line): 상태코드(status code)와 reason message를 포함한다. (예. HTTP/1.1 200 OK. 클라이언트의 요청이 성공적으로 전달되었음을 표시)
응답 헤더필드 (예.Content-Type: text/html)

## Sql injection을 어떻게 막을거냐?
### SQL Injection공격은 무엇인가?
SQL Injection은 웹 어플리케이션에서 DB에 Query시 입력된 데이터의 유효성 검증을 하지 않아,
개발자가 의도하지 않는 동적 쿼리(Dynamic Query) 를 생성하여 DB정보를 열람하거나 조작할 수 있는 보안 취약점 입니다.

### SQL Injection공격은 왜 발생할까?
웹 어플리케이션은 User의 행동(클릭, 입력등)에 따라 DB에 있는 데이터를 서로 다르게 표시합니다.
이를 위해 Query는 User가 입력한 데이터를 포함하여 Dynamic하게 변하므로 개발자가 의도하지 않은 정보를 열람할 수 있게 됩니다.

### SQL Injection공격 방어
#### 1) 입력값 검증
사용자의 입력이 DB Query에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(요효값) 인지 검증합니다.
```java
/*, –, ‘, “, ?, #, (, ), ;, @, =, *, +, union, select, drop, update, from, where, join, substr, user_tables, user_table_columns, information_schema, sysobject, table_schema, declare, dual,…
```
등과 같은 의도하지 않은 입력값에 대해 검증하고 차단해야 합니다.

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 

/* 특수문자 공백 처리 */
final Pattern SpecialChars = Pattern.compile(“[‘\”\\-#()@;=*/+]”);
UserInput = SpecialChars.matcher(UserInput).replaceAll(“”);
final String regex = “(union|select|from|where)”;

final Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
final Matcher matcher = pattern.matcher(UserInput);

if(matcher.find()){
    out.println(“<script>alert(‘No SQL-Injection’);</script>”);
}
```

#### 2) 저장 프로시저 사용
저장 프로시저는 사용하자고 하는 Query에 미리 형식을 지정하는 것을 말합니다. 
지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성을 크게 향상시킵니다.
- 취약코드
```java
try{
  String uId = props.getProperty(“jdbc.uId”);
 

  String query = “SELECT * FROM tb_user WHERE uId=” + uId;
  stmt = conn.prepareStatement(query);
  ResultSet rs = stmt.executeQuery();
  while(rs.next()){
    .. …
  }
}catch(SQLException se){
  .. …
}finally{
  .. …
}
```
- 안전한 코드
```java
try{
  String uId = props.getProperty(“jdbc.uId”);
  String query = “SELECT * FROM tb_user WHERE uId= ?”
  stmt = conn.prepareStatement(query);
  stmt.setString(1, uId);

  ResultSet rs = stmt.executeQuery();
  while(rs.next()){
    .. …
  }
}catch(SQLException se){
  .. …
}finally{
  .. …
}
```

#### 3) 서버 보안
- 최소 권한 유저로 DB 운영
- 사용하지 않는 저장 프로시저와 내장함수 제거 또는 권한 제어
- 목적에 따라 Query권한 수정
- 공용 시스템 객체의 접근 제어
- 신뢰할 수 있는 네트워크, 서버에 대해서만 접근 허용
- 에러 메시지 노출 차단

출처: http://blog.plura.io/?p=6056

## 데이터베이스 설계부터 구현까지의 순서
데이터베이스 설계 순서는 요구분석 - 개념적설계 - 논리적설계 - 물리적설계 - 구현 순으로 이뤄집니다.
- 요구조건 분석 / 명세 ...
- 개념적 설계 (E-R모델) ...
- 논리적 설계 (데이터 모델링) ...
- 물리적 설계 (데이터 구조화) ...
- 데이터베이스 구현

## 스프링이 뭐냐
## 프레임워크의 특징이뭐냐
## IOC DI AOP등…
## 인터셉터를 어따쓰냐
## 스프링 시큐리티써봤냐
## 세션과 쿠키의 차이
## 부트스트랩이 뭔줄아냐
## 깃써봤냐 깃을 왜쓰냐 깃과 깃헙의 차이점이뭐냐
## 자바스크립트가 뭐냐 스크립트언어가 뭔줄아냐
## 제이쿼리가 뭐냐 제이쿼리의 특징
## 제이쿼리 셀렉터
## 노드아냐
## 노드특징과 장단점을 말해봐라
## 동기와 비동기식의 차이점을 아냐
## 그럼 Ajax가 뭔지 설명해봐라
## 콜백함수아냐
## 클로저아냐
## jsp가 뭔줄아냐
## MVC의 대해서 말해봐라 1, 2의 차이
## RDBMS와 No SQL의 차이
## 기본적인 알고리즘
## Mybatis의 장점
