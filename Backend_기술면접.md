## 컴포넌트와 모듈의 차이?
이 두 용어는 다른 많은 용어들과 마찬가지로 소프트웨어가 아닌 다른 필드에서도 많이 사용이 되고 있는데다 모두 소프트웨어 공학에서 동작과 관련되어 나오기 때문에 구분하기가 힘들다.
먼저 각 용어의 배경에 대해 알아보자.
1960년대 그리고 70년대에 들어서면서 소프트웨어가 더 이상 한 사람이 감당하기 힘들 만큼 복잡해지고 커져 새로운 해결책이 필요했다.
이 문제에 대한 지배적인 해결책은 
캡슐화 Encapsulation
정보 숨김 Information hiding
추상 데이터 타입 Abstract data types
이 세가지 였는데 이때까지만 해도 컴퓨터 프로그램이 올바른 답을 계산하는 부분에 초첨을 두고 있다가
이제 어떻게 코드를 구조화하는지가 시스템의 다른 중요한 속성들을 결정을 내린다는 생각이 나오기 시작하면서 Module이라는 개념도 같이 나오게 되었다. 그러면서 70~80년대에 Module Interconnection Language가 도래한다.
대표적으로 Modula modules, Smalltalk 클래스, Ada 패키지, 그리고 오늘날의 지배적인 설계 패러다임인 Object Oriented Programming도 모듈 컨셉을 가지고 있다.

한편 Component는 컴포넌트기반 소프트웨어 공학과 소프트웨어 아키텍처 필드에서 Componenet-and-Connector로 각광을 받고 있다.
두 용어 모두 목적은 전체 시스템을 구성하는 부분 부분으로 분해시키는 것인데 Module의 경우 가장 첫 번째 그리고 가장 맨 앞에 위치하는 구현의 단위이다. Parnas (1972) 의 모듈 설계에서 기본적인 작업은 '정보 숨김'을 기준으로 사용하는 것이었다. 시간이 지날 수록 변하는 정보 예를 들면 데이터 구조나 알고리즘은 모듈에 할당되고 모듈은 접근을 가능하게 하는 인터페이스를 가진다. 모듈은 오랜시간 소스코드와 관련있었지만 정보 모델, XML 파일, config 파일, BNF 파일 등 다른 구현 산출물도 모듈로 적합하다.
Component는 런타임 개체를 참조한다. Szyperski (1998)는 컴포넌트를 "독립적으로 배포될 수 있고 써드 파티로부터의 결합 대상"이라고 말한다. 실제로 운용 모델에서는 컴포넌트가 오직 실행 가능한 바이너리형식으로 전달된다고 한다.
즉, 모듈은 구현 단위와 산출물을 제안는 반면 매체의 전달과 런타임에 일어나는 일은 강조하지 않는다. 컴포넌트는 소프트웨어 활동 단위로 구현 구조에는 가시성이 없다.
좀 더 이해를 명확하게 하려면 Client-Server 시스템의 예를 보면 된다.
하나의 서버가 10개의 클라이언트에게 정보를 제공할 때, 모듈은 2개를 가지지만 컴포넌트는 11개가 된다. 
모듈은 하나의 컴포넌트 또는 여러 개의 컴포넌트로 표현될 수 있고, 컴포넌트도 마찬가지로 하나의 모듈 또는 여러 개의 모듈로 표현될 수 있다. 때로는 모듈과 컴포넌트가 one-to-one 매핑이 될 수 있지만 그럼에도 불구하고 그 둘은 다른 요소라는 것은 분명하다.

출처: https://imcreator.tistory.com/7 [인문과 공학의 사이 어느 중간쯤]

## 자바의 구동원리 (컴파일 순서 같은 ?)
1. 소스코드를 작성한다. (.java 확장자의 소스 파일)
2. 컴파일러(javac.exe)가 바이트코드로 변환한다. (.class 확장자의 클래스 파일)
3. 런처(java.exe)로 자바 가상 머신을 구동시킨다.
4. 자바 가상 머신이 바이트코드를 해석하여 자바 프로그램이 실행된다.
위 순서에서 바이트코드(bytecode)는 자바 가상 머신이 이해할 수 있는 언어로 변환된 코드다. 자바 가상 머신만 설치되어 있다면 바이트코드는 어떤 운영체제에서라도 실행될 수 있다.

## JVM의 특징
즉, 자바 프로그램의 클래스 파일들은 운영체제에서 직접 동작하는 것이 아니라 "JVM" 위에서 동작한다. 그래서 윈도우에서 개발한다면 윈도우용 가상 머신을 설치하고 맥에서 개발한다면 맥용 가상 머신을 설치하는 등의 운영체제용 가상 머신만 설치가 되어 있다면 자바 프로그램은 한 번 만들기만 하면 윈도우든 리눅스든 맥이든, 어느 운영체제든 실행할 수 있다. (=플랫폼 독립성, 이식성이 높다) 
다만, 플랫폼 독립성에 따라 각 운영체제에 맞는 가상 머신을 설치해야 하므로 운영체제에 종속적이다. 그리고 자바 프로그램은 일반 프로그램보다 한 단계를 더 거쳐야 하므로 상대적으로 실행 속도가 느리다는 단점이 있다.

### 왜 자바 가상 머신(JVM) 구조를 알아야 하는가?
출처 : ttp://stophyun.tistory.com/37
백문이 불여일견. 위 사진을 보면 정보시스템의 성능저하 요인 중 무시 못 할 수치로 JVM 및 메모리 문제가 보인다. 시스템의 성능을 높이기 위해 자바 가상 머신의 구성과 메모리를 아는 것은 자바 개발자로서 필수적인 일이다. 특히나 메모리는 사용할 수 있는 공간이 한정되어 있기에 어떻게 관리하느냐에 따라 프로그램의 성능이 좌우된다. 따라서 메모리를 효율적으로 사용하기 위해서는 메모리의 구성과 각 특징에 대해서 이해할 필요가 있다.

### 자바 가상 머신의 구성

출처 : http://gurubee.tistory.com/14
#### 클래스 로더(Class Loader)
런타임 시 클래스 파일들을 JVM 내부로 로딩하고, 클래스 파일을 분석한 뒤에 각각 런타임 데이터 영역에 배치한다. 자바는 동적으로 클래스를 읽어오므로(동적 로딩) 런타임 시점에서야 모든 코드가 JVM과 연결된다. 

#### 런타임 데이터 영역(Runtime Data Areas)
클래스 로더에서 분석된 클래스 파일의 데이터를 저장하고 실행 도중에 필요한 데이터를 저장한다. 메모리를 효율적으로 관리하기 위해 크게 5개의 영역(스태틱, 힙, 스택, PC 레지스터, 네이티브 메서드 스택)으로 구분하며, 간단히 메모리 영역이라고 부른다.

#### 실행 엔진(Execution Engine)
런타임 데이터 영역에 배치된 바이트코드를 해석하며 실행한다. 이 때 인터프리터 방식과 JIT 컴파일 방식을 혼합하여 해석한다.

#### 인터프리터(Interpreter) 방식
바이트코드를 한 줄씩 읽고 해석한다.

#### JIT 컴파일(Just-In-Time compile) 방식
바이트코드를 런타임 시점에 바로 기계어로 변환한다.
최초의 가상 머신은 인터프리터 방식만 써서 실행 속도가 느렸지만, JIT 컴파일 방식을 추가하여 이를 보완하고자 했다. 그런데 JIT 컴파일은 바이트코드를 기계어로 바꾸기 때문에 실행 속도가 빠르지만 변환하는 데 비용이 발생하게 된다. 그래서 인터프리터 방식을 사용하다가 일정한 기준이 넘어가면 JIT 컴파일 방식으로 실행한다.

### 가비지 컬렉터(Garbage Collector)
때에 따라 가비지 컬렉터가 메모리 관리 기능을 자동으로 수행한다. 더 이상 사용되지 않는 객체를 해제시켜 메모리를 자동으로 반납한다.

### 자바의 메모리 영역
런타임 데이터 영역은 실제 클래스 파일들이 배치되는 곳으로, 자바 프로그램을 실행하기 위해서 가상 머신(JVM)이 운영체제로부터 메모리에 데이터 및 명령어를 저장할 공간을 할당받는 곳이다. 5개의 영역으로 분류되지만 주로 메서드, 힙, 스택 영역이 언급된다.

####  메서드(클래스,스태틱)
- 가장 먼저 데이터가 저장되는 공간
- 클래스 로더에 의해 로딩된 클래스, 메서드, 클래스변수(static), 전역변수가 저장됨
- 클래스변수나 전역변수를 무분별하게 많이 사용하면 메모리가 부족할 수 있음
- 프로그램의 시작부터 종료까지 메모리에 남는다.
- 명시적인 Null 선언시 GC 청소대상
- 모든 스레드 공유

####  힙
- 런타임 시 결정되는 참조형 데이터타입이 저장되는 공간
- new 연산자를 통해 생성된 객체가 저장되는 공간
- 객체가 더 이상 안쓰이거나, 명시적인 Null 선언시 GC 청소대상
- 모든 스레드 공유

####  스택
- 컴파일 시 결정되는 기본형 데이터타입이 저장되는 공간
- 지역변수, 매개변수, 리턴값, 참조변수 등이 저장됨
- 메서드 호출될 때, 메모리에 FILO로 하나씩 생성
- 메서드 끝날 때, 메모리에 LIFO로 하나씩 제거
- 메서드 호출시마다 각각의 스택프레임(그 메서드만의 방)이 생성
- { } 또는 메서드가 끝날 때까지 (끝날 땐 프레임별로 삭제)
- 각 스레드별로 생성

#### PC레지스터
- JVM이 수행할 명령어의 주소를 저장하는 공간
- 스레드가 시작될 때마다 생성
- 각 스레드별로 생성

#### 네이티브 메서드 스택
- 바이트코드가 아닌, 기계어로 작성된 코드를 실행하는 공간
- 다른 언어(C/C++)로 작성된 코드를 수행하기 위함
- Java Native Interface를 통해 바이트코드로 변환됨
- Java Native Interface 호출 및 종료시 생성
- 각 스레드별로 생성

출처: https://gbsb.tistory.com/2

## 객체 지향과 절차지향의 차이점

### 절차지향 프로그래밍 -
물이 위에서 아래로 흐르듯 순차적인 처리가 중요합니다. 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다. 대표적인 절차지향 언어로는 C언어가 있습니다. 이는 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빠른 처리 시간을 가지게 되는 점에서 유리합니다. 그러나 기술이 발전되고 소프트웨어, 하드웨어가 발전함에 따라 상황은 많이 달라졌습니다. 전에는 하드웨어와 소프트웨어의 개발 속도의 차가 크지 않았지만 소프트웨어 언어의 발달과 컴파일러의 발달로 하드웨어가 소프트웨어의 발달을 따라오지 못하는 상황이 발생했습니다. 이는 객체지향 언어가 등장하게 되는 계기로 작용했습니다. 객체지향 프로그래밍은 개발하려는 것을 기능별로 묶어 모듈화하며 하드웨어가 같은 기능을 중복으로 연산하지 않도록 하고 모듈을 재활용하여 하드웨어의 처리량을 획기적으로 줄일 수 있게 되었습니다.

### 객체지향 프로그래밍
실제 세계를 모델링해 소프트웨어를 개발하는 방법입니다. 객체지향 프로그래밍에서는 데이터와 절차를 하나의 덩어리로 묶어서 생각합니다. 마치 컴퓨터 부품을 하나씩 구매해 컴퓨터를 조립하는 것과 같은 방식입니다.
객체지향의 3가지 특성에 대해 알아보겠습니다.

#### 1. 캡슐화
캡슐화는 관련된 데이터와 알고리즘(코드)이 하나의 묶음으로 정리된 것으로, 개발자가 만들었으며 관련된 코드와 데이터가 묶여 있고 오류가 없어 사용이 편합니다. 데이터를 감추고 외부 세계와의 상효 작용은 메소드를 통해 이루어지며 라이브러리를 만들어 업그레이드하면 쉽게 바꿀 수 있습니다.
여기서 메소드란 메시지에 따라 실행시킬 프로시저로서 객체지향 언어에서 사용되는 것입니다. 객체 지향 언어에서는 메시지를 보내 메소드를 수행시킴으로써 통신을 수행합니다.

#### 2. 상속
상속은 이미 작성된 클래스를 이어 받아 새로운 클래스를 생성하는 기법으로 위에서 말한 기존 코드를 재활용하여 사용하는 것을 의미합니다. 객체지향의 큰 장점 중 하나입니다.

#### 3. 다형성
다형성은 하나의 이름으로 많은 상황에 대처하는 방법입니다. 개념적으로 동일한 작업을 하는 함수들에 같은 이름을 부여할 수 있으며 코드가 더 간단해지는 효과가 있습니다.

위의 특성들로 생기는 객체지향의 장점은 다음과 같습니다.

- 신뢰성 있는 소프트웨어를 쉽게 작성할 수 있다.
- 코드를 재사용하기 쉽다.
- 업그레이드가 쉽다.
- 디버깅이 쉽다.

이론적으로 본다면 객체지향 언어는 절차지향 언어에 비해서 장점이 많은 편입니다. 하지만 프로그래밍에서 항상 객체지향 언어를 사용하는 것은 아닙니다. 객체지향 언어는 어떤 하나의 기능만 필요하더라도 전체를 가져와야하기 때문에 절차지향 프로그래밍보다 프로그램의 사이즈가 커질 수도 있습니다. 또한 데이터에 접근하는 것도 절차지향보다 상대적으로 느려질 가능성이 많습니다. 메소드를 통해 접근이 가능하기 때문에 절차지향처럼 1개를 딱 찝어 접근할 수 없으며 참조하에 접근이 가능하므로 속도적인 측면에서 불이익이 있습니다.

그럼 절차지향, 객체지향을 어느 때 쓰느냐에 대해 궁금하실 수 있을텐데 이것은 개발자의 몫이라고 볼 수 있습니다. 코드의 사이즈를 최소화하고 가장 빠르게 동작하는 것이 최우선의 목적이라면 객체지향보다는 절차지향을 사용하는게 좋습니다. 대부분 C로 구성하고 C++를 쓴다 하더라도 절차지향의 방식으로 사용합니다. 반면 PC 플랫폼의 경우에는 객체지향이 대세입니다. PC는 모바일 디바이스에 비해 무한한 자원을 확보하기 때문에 위에서 말한 오버로드가 아무 것도 아닌 것이 됩니다. 예를 들면 물이 든 컵에 물 한 수저를 넣으면 높이에 차가 있지만 큰 수영장에 물을 한 수저 넣는다고해서 높이의 차가 거의 생기지 않는 것과 비슷합니다. 그정도의 오버로드는 무시가 될 수 있고 대부분 개발 툴들이 이미 객체지향의 형태로 제공되고 있습니다.

출처: https://loadofprogrammer.tistory.com/144 [큰 꿈을 그리는 프로그래머의 공간.]

## 객체지향 언어의 특징(상속 추상 등등 …)
### 1. 추상화
추상화라고 하는 것은 객체들의 공통적인 특징(속성 과 기능)을 뽑아내는 것이다.
즉, 우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 도출해 내는 것을 의미한다.
추상화는 절차지향 프로그래밍에서도 있어왔다. 대표적인 것이 구조체와 같은 사용자 데이터형이다.
이것은 데이터를 추상화해서 하나의 새로운 데이터 유형을 만드는 것이다. 예를들어 struct와 같은 구조체가 있다.
하나의 새로운 데이터형을 정의하는 데 그 안에는 여러개의 부속데이터를 둘 수 있다. 이 때 그 데이터를 추상화를 통해 정의한 것이다.

### 2. 캡슐화
객체지향에서 캡슐화는 데이터 구조와 데이터를 다루는 방법을 결합시켜 묶는 것을 말한다.
특정 객체가 독립적으로 역할을 제대로 수행하기 위해 필요한 데이터와 기능을 하나로 묶어 관리한다.
객체가 맡은 역할을 수행하기 위한 하나의 목적을 위해 데이터와 기능들을 묶는 것이다.
또한, 이러한 특징은 다른 의미로 사용되기도 한다. 데이터를 은닉하고 그 데이터를 접근하는 기능을 노출시키지 않는다는 의미로 사용할 때 캡슐화라는 용어를 사용한다. 즉, 데이터를 기능이라는 캡슐로 보호한다는 것이다.

### 3. 상속성
상속이 없으면 객체지향은 절차지향과 별 다른 바가 없다.
상속이란 특징을 가지면서 객체지향 언어가 절차지향 언어의 비해 문법의 규모가 2배이상 늘어났다. 상속이란 상위개념의 특징을 하위 개념이 물려받는 것을 말한다. 하나의 클래스가 가지고 있는 특징(데이터와 함수)들을 그대로 다른 클래스가 물려주고자 할 때 상속성의 특징을 사용한다.

### 4. 다형성
가장 까다롭고 이해하기 어려운 특징으로 잘 이해하고 활용한다면 객체지향 언어를 제대로 쓰는 것으로 봐도 무방할 정도이다.
다형성의 의미는 약간 다른 방법으로 일을 하는 함수를 동일한 이름으로 호출해 주는 것을 말한다.

출처: https://sesok808.tistory.com/31 [살아가는 그 이유]

## 상속과 구현의 차이점 과 특징 및 장단점
## 오버라이딩 오버로딩의 차이점과 특징
## 기본형 변수와 참조형 변수가 뭐가있나
## 스택오버 플로우가 왜일어나나
## 메모리 누수가 무엇인가
## 메모리 누수를 막기위해 어떻게 해야하나
## static에 대해 설명해봐라
## 싱글턴이 무엇인가 ? 디자인패턴을 아나 ?
## 익명클래스와 익명객체를 아나?
## 문자열을 끊어서 가져오거나 문자열 검색
## 자료구조 (어레이 링크드 벡터 , 해쉬 맵 셋 등…) 특징과 장단점 (특히 벡터와 리스트의 차이점 과 특징)
## 스레드는 언제쓰고 쓰레드가 무엇인가
## 멀티쓰레드와 쓰레드의 차이점
## 제네릭이란 무엇인가
## 람다식이란 무엇인가
## 힙과 스택의 차이점을 알고있는가
## TCP와 UDP의 차이점
## http프로토콜에대해서아냐 ?
## Sql injection을 어떻게 막을거냐?
## 데이터베이스 설계부터 구현까지의 순서
## 스프링이 뭐냐
## 프레임워크의 특징이뭐냐
## IOC DI AOP등…
## 인터셉터를 어따쓰냐
## 스프링 시큐리티써봤냐
## 세션과 쿠키의 차이
## 부트스트랩이 뭔줄아냐
## 깃써봤냐 깃을 왜쓰냐 깃과 깃헙의 차이점이뭐냐
## 자바스크립트가 뭐냐 스크립트언어가 뭔줄아냐
## 제이쿼리가 뭐냐 제이쿼리의 특징
## 제이쿼리 셀렉터
## 노드아냐
## 노드특징과 장단점을 말해봐라
## 동기와 비동기식의 차이점을 아냐
## 그럼 Ajax가 뭔지 설명해봐라
## 콜백함수아냐
## 클로저아냐
## jsp가 뭔줄아냐
## MVC의 대해서 말해봐라 1, 2의 차이
## RDBMS와 No SQL의 차이
## 기본적인 알고리즘
## Mybatis의 장점
